# --------------------------------------------------------
# ~/.zshrc â€” unified for Fedora + macOS (Oh My Zsh + p10k)
# --------------------------------------------------------

# --- Detect OS/Arch early ---
OS=${OSTYPE}
IS_DARWIN=false
IS_LINUX=false
[[ "$OS" == darwin* ]] && IS_DARWIN=true
[[ "$OS" == linux* ]] && IS_LINUX=true

# --- Powerlevel10k instant prompt (must stay at the very top) ---
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# --- XDG base dirs (helpful on macOS where theyâ€™re often unset) ---
: "${XDG_CONFIG_HOME:=$HOME/.config}"
: "${XDG_CACHE_HOME:=$HOME/.cache}"
: "${XDG_STATE_HOME:=$HOME/.local/state}"

# --- Oh My Zsh base path ---
export ZSH="$HOME/.oh-my-zsh"

# --- Completions path BEFORE OMZ loads so compinit sees it ---
fpath+=(${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins/zsh-completions/src)

# --- Fast, quiet completion cache (prevents compaudit prompts) ---
export ZSH_COMPDUMP="${XDG_CACHE_HOME}/zsh/.zcompdump-$ZSH_VERSION"
mkdir -p "${ZSH_COMPDUMP:h}"
ZSH_DISABLE_COMPFIX="true"

# --- Theme ---
ZSH_THEME="powerlevel10k/powerlevel10k"

# --- Plugins (lean for speed) ---
# Note: 'fzf' removed from here to avoid double-loading (handled manually below)
plugins=(
  git
  zsh-autosuggestions
  fast-syntax-highlighting   # Ensure this is cloned into $ZSH_CUSTOM/plugins
)

# --- Load Oh My Zsh (if present) ---
[[ -r "$ZSH/oh-my-zsh.sh" ]] && source "$ZSH/oh-my-zsh.sh"

# -------------------- QoL & performance --------------------

# History (large, deduped, timestamped)
HISTSIZE=50000
SAVEHIST=50000
HISTFILE="${XDG_STATE_HOME}/zsh/history"
mkdir -p "${HISTFILE:h}"
setopt APPEND_HISTORY INC_APPEND_HISTORY SHARE_HISTORY
setopt HIST_IGNORE_DUPS HIST_IGNORE_ALL_DUPS HIST_REDUCE_BLANKS HIST_VERIFY
setopt EXTENDED_HISTORY

# Shell behaviour
setopt INTERACTIVE_COMMENTS     # allow comments at prompt
setopt AUTO_CD                  # `cd dir` â†’ `dir`
setopt NO_FLOW_CONTROL          # avoid ^S/^Q freezes
setopt COMPLETE_IN_WORD         # complete in the middle of words

# Completion styles (friendlier matching & menu selection)
zmodload zsh/complist
zstyle ':completion:*' completer _complete _correct _approximate
zstyle ':completion:*' menu select
zstyle ':completion:*' matcher-list \
  'm:{a-z}={A-Z}' \
  'r:|[._-]=* r:|=*' \
  'l:|=* r:|=*'

# -------------------- PATH hygiene --------------------
# Common user bins first
export PATH="$HOME/.local/bin:$HOME/bin:$PATH"

# macOS: Homebrew (Optimized: No slow 'brew --prefix' subshell)
if $IS_DARWIN; then
  # 1. Check Apple Silicon path
  if [[ -d "/opt/homebrew/bin" ]]; then
    export PATH="/opt/homebrew/bin:/opt/homebrew/sbin:$PATH"
    BREW_PREFIX="/opt/homebrew"
  # 2. Check Intel path
  elif [[ -d "/usr/local/bin" ]]; then
    export PATH="/usr/local/bin:/usr/local/sbin:$PATH"
    BREW_PREFIX="/usr/local"
  fi

  # 3. Add GNU Coreutils (gnubin) if present
  if [[ -n "$BREW_PREFIX" && -d "$BREW_PREFIX/opt/coreutils/libexec/gnubin" ]]; then
    export PATH="$BREW_PREFIX/opt/coreutils/libexec/gnubin:$PATH"
  fi
fi

# -------------------- fzf integration --------------------
# Fedora packaged fzf scripts
if $IS_LINUX; then
  [[ -f /usr/share/fzf/shell/key-bindings.zsh ]] && source /usr/share/fzf/shell/key-bindings.zsh
  [[ -f /usr/share/fzf/shell/completion.zsh    ]] && source /usr/share/fzf/shell/completion.zsh
fi

# macOS Homebrew fzf scripts
if $IS_DARWIN && [[ -n "$BREW_PREFIX" ]]; then
  FZF_DIR="$BREW_PREFIX/opt/fzf/shell"
  [[ -f "$FZF_DIR/key-bindings.zsh" ]] && source "$FZF_DIR/key-bindings.zsh"
  [[ -f "$FZF_DIR/completion.zsh"    ]] && source "$FZF_DIR/completion.zsh"
fi

# -------------------- Language/toolchain shims --------------------

# pyenv (required)
export PYENV_ROOT="$HOME/.pyenv"
export PATH="$PYENV_ROOT/bin:$PATH"
if command -v pyenv >/dev/null 2>&1; then
  eval "$(pyenv init - zsh)"
  eval "$(pyenv virtualenv-init -)"
fi

# -------------------- TeX Live / MacTeX --------------------
if $IS_LINUX; then
  # TeX Live (Linux) - Dynamically find the newest year installed
  # (N) = nullglob (don't error if missing), (On) = Order by Name descending
  local tex_dirs=(/usr/local/texlive/*(N/On))
  if (( ${#tex_dirs} > 0 )); then
    export PATH="${tex_dirs[1]}/bin/x86_64-linux:$PATH"
    export MANPATH="${tex_dirs[1]}/texmf-dist/doc/man:${MANPATH:-}"
    export INFOPATH="${tex_dirs[1]}/texmf-dist/doc/info:${INFOPATH:-}"
  fi
elif $IS_DARWIN; then
  # MacTeX universal symlink
  export PATH="/Library/TeX/texbin:$PATH"
fi

# -------------------- Aliases (minimal, additive) --------------------

alias ls='lsd --icon auto'
alias ll='lsd -lh --git --icon auto'
alias la='lsd -la --git --icon auto'
alias lt='lsd --tree --depth=2 --icon auto'

alias gs='git status'
alias gc='git commit -v'
alias gp='git push'

alias Workspace='cd $HOME/workspace/ && la'
alias Projects='cd $HOME/workspace/projects/ && la'
alias Thirdway='cd $HOME/workspace/projects/thirdway/ && la'
alias Koralis='cd $HOME/workspace/projects/koralis-ai && la'
alias Kairos='cd $HOME/workspace/projects/kairos-flow && la'

# -------------------- Prompt/theme config --------------------
[[ -r "$HOME/.p10k.zsh" ]] && source "$HOME/.p10k.zsh"

# 1Password SSH Agent
export SSH_AUTH_SOCK="$HOME/.1password/agent.sock"

# chezmoi aliases
alias cz='chezmoi'
alias czp='chezmoi git add . && chezmoi git commit -m "update" && chezmoi git push'

# -------------------- smart sync helpers --------------------

# Sync from home â†’ chezmoi â†’ git â†’ remote
function dot-push() {
  echo "ğŸ§­ Adding and pushing chezmoi changes..."

  # Only add files that actually exist on this machine
  local -a files=(~/.zshrc ~/.p10k.zsh ~/.config/starship.toml)
  local f
  for f in "${files[@]}"; do
    [[ -e "$f" ]] && chezmoi add "$f"
  done

  (
    cd "$(chezmoi source-path)" || { echo "âŒ Could not enter chezmoi source dir."; exit 1; }

    # If both working tree and index are clean, bail out nicely
    if git diff --quiet && git diff --cached --quiet; then
      echo "â„¹ï¸  No changes to commit."
      exit 0
    fi

    git add -A
    git commit -m "${1:-update dotfiles}"
    # Use HEAD so we don't accidentally push to 'main' if we are on a dev branch
    git push -u origin HEAD
  ) && echo "âœ… Dotfiles pushed."
}


# Pull from remote â†’ apply to home
function dot-pull() {
  echo "â¬‡ï¸  Updating chezmoi from GitHub..."

  # Ensure we're on the correct branch
  (
    cd "$(chezmoi source-path)" || {
      echo "âŒ Could not enter chezmoi source dir."
      return 1
    }
    # Fetch & show current branch
    current_branch=$(git symbolic-ref --short HEAD 2>/dev/null || echo "unknown")
    echo "ğŸ“¦ Current branch: $current_branch"
  )

  # Update from remote and apply changes to $HOME
  if chezmoi update -v; then
    echo "âœ… Dotfiles updated and applied."
  else
    echo "âŒ ChezMoi update failed."
    return 1
  fi
}



